# -*- coding: utf-8 -*-
"""BuyogoTask.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rl9SAt-TApL2hG_5ToAVpMAzzdrOAC69
"""

#importing libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')
import faiss
from sentence_transformers import SentenceTransformer
from transformers import pipeline
from flask import Flask, jsonify
import requests # Import requests directly
import torch

#load a dataset

from google.colab import files
uploaded = files.upload()

#Read the data
df = pd.read_csv('hotel_bookings.csv')
# Display dataset information
print("Dataset Info:\n")
df.info()

# Show first 5 rows
print("\nFirst 5 Rows:\n", df.head())

#handle missing data
# Check for missing values
missing_values = df.isnull().sum()
print("\nMissing Values:\n", missing_values[missing_values > 0])
# Fill missing values
df.fillna({
    'children': 0,
    'country': 'Unknown',
    'agent': 0,
    'company': 0
}, inplace=True)

print("\nMissing values handled successfully!")

# Convert reservation status date to datetime format
df['reservation_status_date'] = pd.to_datetime(df['reservation_status_date'])

# Create a new date column for revenue analysis
df['arrival_date'] = pd.to_datetime(df['arrival_date_year'].astype(str) + '-' + df['arrival_date_month'].astype(str) + '-01')

print("\nDate columns converted successfully!")

# Save cleaned dataset
df.to_csv("cleaned_hotel_bookings.csv", index=False)
print("\nCleaned dataset saved successfully!")

#review trend analysis

# Revenue trends over time
revenue_trends = df.groupby('arrival_date')['adr'].sum()

plt.figure(figsize=(12, 6))
plt.plot(revenue_trends.index, revenue_trends.values, marker='o')
plt.title("Revenue Trends Over Time")
plt.xlabel("Date")
plt.ylabel("Total Revenue")
plt.grid()
plt.show()

# Compute cancellation rate
cancellation_rate = (df['is_canceled'].sum() / len(df)) * 100
print(f"\nCancellation Rate: {cancellation_rate:.2f}%")

#Geographical Distribution of Bookings
# Plot country-wise bookings
plt.figure(figsize=(90, 25))
df['country'].value_counts().plot(kind='bar')
plt.title("Geographical Distribution of Bookings")
plt.xlabel("Country")
plt.ylabel("Number of Bookings")
plt.show()

# Plot Booking lead time distribution
plt.figure(figsize=(12, 6))
sns.histplot(df['lead_time'], bins=50, kde=True)
plt.title("Booking Lead Time Distribution")
plt.xlabel("Lead Time (days)")
plt.ylabel("Frequency")
plt.show()

#Text Embedding & FAISS Index Creatio
# Prepare text data
text_data = df[['hotel', 'country', 'reserved_room_type']].astype(str).agg(' '.join, axis=1).tolist()

# Load Sentence Transformer Model
model = SentenceTransformer('all-MiniLM-L6-v2')

# Generate embeddings in batches
batch_size = 512
embeddings = []

for i in range(0, len(text_data), batch_size):
    batch = text_data[i:i+batch_size]
    batch_embeddings = model.encode(batch, normalize_embeddings=True)
    embeddings.append(batch_embeddings)

embeddings = np.vstack(embeddings)

# Create FAISS index
index = faiss.IndexFlatL2(embeddings.shape[1])
index.add(embeddings)

print("FAISS Index Created Successfully!")

#Implement Question Answering (RAG)
# Load Question Answering model
qa_pipeline = pipeline("question-answering", model="deepset/roberta-base-squad2")

# Define function for answering questions
def answer_question(question):
    query_embedding = model.encode([question], normalize_embeddings=True)
    distances, indices = index.search(np.array(query_embedding), k=1)
    best_match = text_data[indices[0][0]]
    return qa_pipeline(question=question, context=best_match)['answer']

#Flask API for Analytics & QA
app = Flask(__name__)

@app.route('/analytics', methods=['POST'])
def get_analytics():
    return jsonify({
        "cancellation_rate": f"{cancellation_rate:.2f}%",
        "revenue_trends": revenue_trends.to_dict()
    })

@app.route('/ask', methods=['POST'])
def ask_question():
    data = request.json
    question = data.get("question", "")
    answer = answer_question(question)
    return jsonify({"answer": answer})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)

